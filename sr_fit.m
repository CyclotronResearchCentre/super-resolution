function [out,in] = sr_fit(in,opt)
% Super-resolution/denoising of multichannel images.
%
%   . This model assumes that data are generated by projecting noise-free
%     high-res images to a low-resolution space and adding Gaussian noise.
%   . A multi-channel total-variation (MTV) prior is set over the unknown
%     high-res images and a maximum a posteriori (MAP) or an approximate
%     Gaussian posterior (mean + variance) is estimated.
%   . The non-differentiable L1 problem is solved using a reweighted
%     least-squares (RLS) approach.
%   . Additionally, the unknown images can evenutally be encoded in
%     log-space, such that the forward model is 'x = A*exp(y) + eps' 
%     instead of 'x = A*y + eps'. This ensures that the reconstructed 
%     images are positive and that the prior is scale-invariant. The
%     problem becomes non-convex but still possesses a unique optimum.
%
% FORMAT out = sr_fit(in,opt)
%
% in   - Input volumes.
% opt  - Structure of parameters.
% out  - Output data structure.
%
% Input volumes can be:
% - (cell|array) of (cell|array) of (string|char|nifti):
%       . Each filename corresponds to one 3D volume.
%       . Outer loop: contasts | Inner loop: repeats
%       . 4D volumes will be treated as series of 3D volumes.
%       . Specific volumes from a 4D series can be specified using SPM's
%         notation (e.g., 'path/to/file.nii,2' for the 2nd volume)
% - (numeric|file) array:
%       . For denoising only.
%       . All inputs must have the same lattice and are assumed to have the
%         same orientation matrix. This orientation matrix can be specified
%         in the option structure.

% -------------------------------------------------------------------------
%
%                           Initialisation
% 
% -------------------------------------------------------------------------

% -------------------------------------------------------------------------
% Options
if nargin < 2, opt = struct; end
opt = sr_opt_defaults(opt);

% -------------------------------------------------------------------------
% Multithread SPM
[threads0.spm,threads0.matlab] = sr_threads();
sr_threads(opt.threads, 'both');

% -------------------------------------------------------------------------
% Read and format input volumes
if opt.verbose > 0, fprintf('Read input volumes\n'); end
in = sr_in_format(in,opt);

% > Here, dat is a cell of cell of struct with fields:
% . dat - observed data (numeric or file array)
% . mat - orientation matrix
% . dim - lattice dimensions
% . var - observation uncertainty (numeric or file array, usually a scalar)
% . lam - noise precision
% . mu  - mean tissue intensity

% DEBUG: LENA
% in{1}{1}.lam = 1/20^2;
% in{2}{1}.lam = 1/20^2;
% in{3}{1}.lam = 1/20^2;

% -------------------------------------------------------------------------
% Co-registration
if opt.coreg.do
    if opt.verbose > 0, fprintf('Coregister volumes\n'); end
    in = sr_in_coregister(in,opt.coreg.fwhm);
end

% -------------------------------------------------------------------------
% Create output structure
[dim,mat,vs] = compute_mean_space(in,opt);
if opt.verbose > 0, fprintf('Prepare output structure\n'); end
out = sr_out_format(dim, mat, in, opt);

% Here, out is a structure with fields:
% . dat   - denoised/upsampled data, as a 4D (numeric|file) array
% . mat   - orientation matrix
% . dim   - lattice dimensions
% . lam   - regularisation value
% . rls   - image of weights (RLS)
% . uncty - uncertainty images

% -------------------------------------------------------------------------
% Initialise uncertainty
if opt.reg.uncertainty == 0
    if opt.verbose > 0, fprintf('Initialise uncertainty: '); end
    for c=1:numel(in)
        H1 = sr_hessian(c, in{c}, out, opt);
        H2 = out.lam(c)*sr_diag_kernel(vs);
        out.uncty(:,:,:,c) = 1./(H1 + H2);
    end
    fprintf('\n');
    clear H1 H2
end

% -------------------------------------------------------------------------
%
%                         Iterative optimisation
% 
% -------------------------------------------------------------------------

if opt.verbose > 0, fprintf('Full nonlinear fit\n'); end
if opt.verbose > 1, sr_plot_progress(in, out,[],opt); end
ll  = [];
K   = size(out.dat, 4);
scl = sr_diag_kernel(vs); % Diag of convolution kernel (D'D)
for it=1:opt.itermax

    if opt.verbose > 0, fprintf('Iteration %i\n', it); end

    % ---------------------------------------------------------------------
    % Update maps
    % ---------------------------------------------------------------------
    g   = zeros([dim K], 'single');            % Gradient
    H   = zeros([dim K], 'single');            % Hessian
    llx = 0;                                   % Log-likelihood: data term
    lly = 0;                                   % Log-likelihood: prior term
    llu = 0;                                   % Log-likelihod: uncertainty
    lltv = 0;                                  % True MTV term
    
    % ---------------------------------------------------------------------
    % Gradient: data term
    % ---------------------------------------------------------------------
    if opt.verbose > 0, fprintf('Gradient: data '); end
    for c=1:numel(in) % Loop over contrasts
        
        % - Compute gradient
        [llx1,g1,H1] = sr_gradient(c, in{c}, out, opt);
        llx          = llx + llx1;

        % - Add to full gradient
        g(:,:,:,c) = g(:,:,:,c) + g1; clear g1
        H(:,:,:,c) = H(:,:,:,c) + H1;
        clear H1

    end
    if opt.verbose > 0, fprintf('\n'); end
    
    % ---------------------------------------------------------------------
    % Gradient: Membrane
    % ---------------------------------------------------------------------
    if opt.reg.mode > 0
        if opt.verbose > 0, fprintf('Gradient: membrane '); end
        switch opt.reg.mode
            % -------------------------------------------------------------
            % L1 regularisation
            case 1
                wnew = 0;
                w    = single(out.rls());
                lly  = lly + 0.5*sum(w(:),'double');
                w    = 1./w;
                for k=1:K
                    if opt.verbose > 0, fprintf('.'); end
                    y          = single(out.dat(:,:,:,k));
                    [Ly,Dy]    = sr_vel2mom_l1(y, out.lam(k), vs, w);
                    Dy         = sum(sum(Dy.^2,5),4);
                    wnew       = wnew + Dy;
                    g(:,:,:,k) = g(:,:,:,k) + Ly;
                    lly        = lly + 0.5*sum(y(:).*Ly(:), 'double');
                    clear Ly
                end
                lltv = lltv + sum(sqrt(wnew(:)), 'double');
                if opt.reg.uncertainty == 0
                    u    = single(out.uncty());
                    u    = bsxfun(@times, u, reshape(out.lam*scl, 1,1,1,[]));
                    wnew = sqrt(wnew + sum(u, 4));
                else
                    wnew = sqrt(wnew + opt.reg.uncertainty);
                end
                out.rls(:,:,:) = wnew; clear wnew
            
            % -------------------------------------------------------------
            % L2 regularisation
            case 2
                for k=1:K
                    if opt.verbose > 0, fprintf('.'); end
                    y          = single(out.dat(:,:,:,k));
                    Ly         = sr_vel2mom_l2(y, out.lam(k), vs);
                    g(:,:,:,k) = g(:,:,:,k) + Ly;
                    lly        = lly + 0.5*sum(y(:).*Ly(:), 'double');
                    clear y Ly
                end
        end
        if opt.verbose > 0, fprintf('\n'); end
    end


    % ---------------------------------------------------------------------
    % Load diagonal of the Hessian
    % ---------------------------------------------------------------------
    H = bsxfun(@plus, H, sum(H,4) * 1E-3);
    
    % ---------------------------------------------------------------------
    % Gauss-Newton
    % ---------------------------------------------------------------------
    switch opt.reg.mode
        % -----------------------------------------------------------------
        % No regularisation
        case 0
            dy = sr_solve_l0(H, g);
            
        % -----------------------------------------------------------------
        % L1 regularisation
        case 1
            dy = opt.solver.fun(H, g, w, out.lam, vs, opt.solver);
            if opt.reg.uncertainty == 0
                u = sr_uncertainty_l1(H, out.lam, vs, w);
                out.uncty(:,:,:,:) = u;
                llu = llu - 0.5*sum(log(u(:)), 'double');
                llu = llu + 0.5*sum(H(:).*u(:), 'double');
                u   = bsxfun(@times, u, reshape(scl*out.lam, 1,1,1,[]));
                u   = bsxfun(@times, u, w);
                llu = llu + 0.5*sum(H(:).*u(:), 'double');
                clear u
            end
            
        % -----------------------------------------------------------------
        % L2 regularisation
        case 2
            dy = sr_solve_l2(H, g, out.lam, vs);
    end
    clear H g w
    
    % ---------------------------------------------------------------------
    % Update
    if opt.verbose > 0, fprintf('Update\n'); end
    for k=1:K
        out.dat(:,:,:,k) = out.dat(:,:,:,k) - 0.9*dy(:,:,:,k);
    end
    clear dy

    if it > 1
    % ---------------------------------------------------------------------
    % Log-likelihood + Gain
    % ---------------------------------------------------------------------
    ll = [ll, [llx+lly+llu;llx;lly;llu;lltv]];
    if size(ll,2) > 1
        gain = abs((ll(1,end-1) - ll(1,end)) / (max(ll(1,:)) - ll(1,end-1)));
    else
        gain = Inf;
    end

    % ---------------------------------------------------------------------
    % Plot
    % ---------------------------------------------------------------------
    if opt.verbose > 0, fprintf('%s\n', repmat('-',[1 80])); end
    if opt.verbose > 0, fprintf('ll = %7.3g | llx = %7.3g | lly = %7.3g | gain = %7.3g\n', ll(end), llx, lly, gain); end
    if opt.verbose > 0, fprintf('%s\n', repmat('-',[1 80])); end

    % ---------------------------------------------------------------------
    % Out?
    % ---------------------------------------------------------------------
    if abs(gain) < opt.tolerance
        if opt.verbose > 1, sr_plot_progress(in, out, ll, opt); end
        break
    end
    end
    if opt.verbose > 1, sr_plot_progress(in, out, ll, opt); end

end

sr_out_write(out, in, opt);

sr_threads(threads0.spm,    'spm');
sr_threads(threads0.matlab, 'matlab');

% =========================================================================

function [dim,mat,vs] = compute_mean_space(in,opt)
if opt.fov == 0
    % Estimate a mean orientation matrix
    if opt.verbose > 0, fprintf('Estimate mean space\n'); end
    num = zeros(1,numel(in));
    for c=1:numel(in), num(c) = numel(in{c}); end
    allmat = zeros(4,4,prod(num));
    alldim = zeros(3,prod(num));
    i = 0;
    for c=1:numel(in)
        for n=1:numel(in{c})
            i = i + 1;
            allmat(:,:,i) = in{c}{n}.mat;
            alldim(:,i)   = in{c}{n}.dim(:);
        end
    end
    [dim,mat,vs] = sr_mean_space(allmat, alldim, opt.vs);
else
    % Use orientation matrix of the n-th volume
    mat = in{opt.fov}.mat;
    dim = in{opt.fov}.dim;
    vs0 = sqrt(sum(mat(1:3,1:3).^2,4));
    vs  = vs0;
    vs(isfinite(opt.vs)) = opt.vs(isfinite(opt.vs));
    scl  = vs0(:)./vs(:);
    mat = mat * diag([scl(:); 1]);
    dim = ceil(dim(:).*scl(:))';
end